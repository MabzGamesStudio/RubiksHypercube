using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Handles the movement, turning, and coloring of the cube
/// Image for calculating the sticker indexes:
/// https://docs.google.com/drawings/d/1QZtMYhk2xlsxUIr0iPR55bRf_jm7EjRWzyTNLjw1g6g/edit?usp=sharing
/// The creation of the cycles were generated by the Mathematica code located in
/// the "Mathematica" folder
/// IMPORTANT:
/// The hypersticker indexes start at 1 because Mathematica starts at index 1
/// </summary>
public class CubeTurner : MonoBehaviour
{
	/// <summary>
	/// Prefab of the cube core
	/// </summary>
	public GameObject corePrefab;

	/// <summary>
	/// Prefab of the 3x3 cube face stickers
	/// </summary>
	public GameObject facePrefab;

	/// <summary>
	/// Prefab of the axis of rotation in turning the hypercube
	/// </summary>
	public GameObject turnAxisPrefab;

	/// <summary>
	/// Colors of the stickers in order of the hyperfaces: red, orange, white,
	/// yellow, blue, green
	/// </summary>
	public Material[] colors;

	/// <summary>
	/// Colors of the stickers when selected in order of the hyperfaces:
	/// red, orange, white, yellow, blue, green
	/// </summary>
	public Material[] colorsSelected;

	/// <summary>
	/// Script to activate the confetti on solve
	/// </summary>
	public ConfettiScript confetti;

	/// <summary>
	/// Text script to display the sticker moves in the scramble
	/// </summary>
	public ScrambleText scrambleText;

	/// <summary>
	/// Text script to display the sticker moves in the solve
	/// </summary>
	public SolveText solveText;

	/// <summary>
	/// Script of the button that toggles whether the sticker colors are showing
	/// </summary>
	public CubeButton showColorsButton;

	/// <summary>
	/// Script of the solve timer
	/// </summary>
	public CubeTimer timer;

	/// <summary>
	/// Axis of rotation around the line formed from the center to the noted
	/// sticker piece with the following axis indexes:
	/// 0: FaceTop, 1: FaceRight, 2: FaceFront
	/// </summary>
	public enum TurnAxis
	{
		FaceTop,
		FaceRight,
		FaceFront,
		None
	}

	/// <summary>
	/// Sticker type in reference to the face
	/// </summary>
	private enum StickerType
	{
		Center,
		Edge,
		Corner
	}

	/// <summary>
	/// Type of rotation in direction and amount of rotation
	/// </summary>
	public enum TurnType
	{
		Clockwise,
		HalfTurn,
		CounterClockwise,
		FaceCentralizer,
		None
	}

	/// <summary>
	/// Perspective of view of the cube
	/// </summary>
	public enum Perspective
	{
		Top,
		Normal,
		Bottom
	};

	/// <summary>
	/// Whether the sticker colors of the cube are showing
	/// </summary>
	public bool showingColors = true;

	/// <summary>
	/// Array of faces
	/// </summary>
	private GameObject[] faces;

	/// <summary>
	/// Core pieces parent
	/// </summary>
	private GameObject core;

	/// <summary>
	/// Array of all stickers
	/// </summary>
	private GameObject[] stickers;

	/// <summary>
	/// Array of all core cubies
	/// </summary>
	private GameObject[] coreCubies;

	/// <summary>
	/// Mesh renderers of all the stickers
	/// </summary>
	private MeshRenderer[] cubiesMeshRenderers;

	/// <summary>
	/// Transform parents of the stickers/cubies moved in turn animation
	/// </summary>
	private Transform[] cubeTurnStickerParents;

	/// <summary>
	/// Transforms of the stickers/cubies moved in turn animation
	/// </summary>
	private Transform[] cubeTurnStickerChildren;

	/// <summary>
	/// Array of gameobjects of the turn axis for the turn animation
	/// </summary>
	private GameObject[] turnAxis;

	/// <summary>
	/// Colors of the stickers of the cube
	/// </summary>
	private int[] cubeColors;

	/// <summary>
	/// Game object parent of the central 6 faces and core
	/// </summary>
	private GameObject mainSection;

	/// <summary>
	/// Whether the cube is currently in the turn animation
	/// </summary>
	private bool isTurning;

	/// <summary>
	/// Timer progression of the turn animation
	/// </summary>
	private float turnTimer = 0f;

	/// <summary>
	/// Current turn axis being rotated around
	/// </summary>
	private TurnAxis currentTurnAxis;

	/// <summary>
	/// Current sticker move
	/// </summary>
	private int currentTurnSticker;

	/// <summary>
	/// Current rotation degrees around turn axis
	/// </summary>
	private float currentTurnDegrees;

	/// <summary>
	/// Current type of turn being performed
	/// </summary>
	private TurnType currentTurnType;

	/// <summary>
	/// Time elapsed over turn animation
	/// </summary>
	private static float turnTime = .5f;

	/// <summary>
	/// Time elapsed over sticker select animation
	/// </summary>
	private static float switchTime = .2f;

	/// <summary>
	/// Distance between the faces
	/// </summary>
	private static float faceDistance = 1.5f;

	/// <summary>
	/// Whether to use the turn animation
	/// </summary>
	private bool showTurn = true;

	/// <summary>
	/// Number of sticker turns in scramble of cube
	/// </summary>
	private static int scrambleMoves = 100;

	/// <summary>
	/// Scaling factor of the size of the cube
	/// </summary>
	private static float cubeScale = 0.1f;

	/// <summary>
	/// Position of the cube in space
	/// </summary>
	private static Vector3 cubePosition = new Vector3(0f, 1.1f, 1f);

	/// <summary>
	/// Offset of the perspective shift of the cube
	/// </summary>
	private static float perspectiveOffset = 1f;

	/// <summary>
	/// Whether the confetti solve animation is currently in progress
	/// </summary>
	private bool solveAnimation;

	/// <summary>
	/// Time elapsed during the solve
	/// </summary>
	private float solveAnimationTime;

	/// <summary>
	/// Whether the cube has been scrambled
	/// </summary>
	private bool cubeScrambled;

	/// <summary>
	/// Names of the faces in order
	/// </summary>
	private static string[] sideNames = new string[]
	{
		"Front", "Back", "Top", "Bottom", "Right", "Left"
	};

	/// <summary>
	/// Euler angles of rotation of each face in order
	/// </summary>
	private Vector3[] cubesEulerAngles = new Vector3[]
	{
		new Vector3(-90, 0, 0),
		new Vector3(90, 0, 0),
		new Vector3(0, 0, 0),
		new Vector3(180, 0, 0),
		new Vector3(0, 0, -90),
		new Vector3(0, 0, 90)
	};

	/// <summary>
	/// Positions of the faces in space relative to center
	/// </summary>
	private Vector3[] facePositions = new Vector3[]
	{
		new Vector3(0, 0, -faceDistance),
		new Vector3(0, 0, faceDistance),
		new Vector3(0, faceDistance, 0),
		new Vector3(0, -faceDistance, 0),
		new Vector3(faceDistance, 0, 0),
		new Vector3(-faceDistance, 0, 0)
	};

	/// <summary>
	/// This maps the order of the sticker based on its creation to the sticker
	/// index used universally
	/// Sticker creation is different due to the rotations of the hyperfaces
	/// which change the relative sticker index positions
	/// </summary>
	private int[] cubiesMapping = new int[]
	{
		0, 1, 2, 3, 4, 5, 6, 7, 8,
		15, 16, 17, 12, 13, 14, 9, 10, 11,
		18, 19, 20, 21, 22, 23, 24, 25, 26,
		33, 34, 35, 30, 31, 32, 27, 28, 29,
		42, 39, 36, 43, 40, 37, 44, 41, 38,
		45, 48, 51, 46, 49, 52, 47, 50, 53
	};

	/// <summary>
	/// The list of sticker indexes that move in the turn animation of each
	/// turn index: front, back, top, bottom, right, left
	/// </summary>
	private int[,] turnStickers = new int[,]
	{

		// Front turn stickers
		{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 28, 29, 30, 37, 40, 43, 19, 20, 21, 46, 49, 52 },
		
		// Back turn stickers
		{ 10, 11, 12, 13, 14, 15, 16, 17, 18, 34, 35, 36, 39, 42, 45, 25, 26, 27, 48, 51, 54 },
		
		// Top turn stickers
		{ 19, 20, 21, 22, 23, 24, 25, 26, 27, 7, 8, 9, 43, 44, 45, 16, 17, 18, 52, 53, 54 },
		
		// Bottom turn stickers
		{ 28, 29, 30, 31, 32, 33, 34, 35, 36, 1, 2, 3, 37, 38, 39, 10, 11, 12, 46, 47, 48 },
		
		// Right turn stickers
		{ 37, 38, 39, 40, 41, 42, 43, 44, 45, 30, 33, 36, 3, 6, 9, 12, 15, 18, 21, 24, 27 },
		
		// Left turn stickers
		{ 46, 47, 48, 49, 50, 51, 52, 53, 54, 28, 31, 34, 1, 4, 7, 19, 22, 25, 10, 13, 16 }
	};

	/// <summary>
	/// The list of cubie indexes that move in the turn animation of each
	/// turn index: front, back, top, bottom, right, left
	/// </summary>
	private int[,] turnCubies = new int[,]
	{

		// Front turn stickers
		{ 1, 2, 3, 10, 11, 12, 19, 20, 21 },
		
		// Back turn stickers
		{ 7, 8, 9, 16, 17, 18, 25, 26, 27 },
		
		// Top turn stickers
		{ 19, 20, 21, 22, 23, 24, 25, 26, 27 },
		
		// Bottom turn stickers
		{ 1, 2, 3, 4, 5, 6, 7, 8, 9 },
		
		// Right turn stickers
		{ 3, 6, 9, 12, 15, 18, 21, 24, 27 },
		
		// Left turn stickers
		{ 1, 4, 7, 10, 13, 16, 19, 22, 25 }
	};

	/// <summary>
	/// Initializes cube, faces, stickers, turn axis, and button
	/// that displays sticker colors to showing
	/// </summary>
	void Start()
	{
		SetupCubeStructure();
		AssignCubies();
		SetupTurnAxis();
		showColorsButton.SetButtonToggle(true);
	}

	/// <summary>
	/// Updates the data and animations of the turn or solve
	/// </summary>
	private void Update()
	{
		UpdateSolveAnimation();
		UpdateCubeTurn();
	}

	/// <summary>
	/// Updates the animation of the solve animation
	/// </summary>
	private void UpdateSolveAnimation()
	{

		// If solve animation in progress, elapse time
		if (solveAnimation)
		{
			solveAnimationTime -= Time.deltaTime;

			// If time has elapsed, the animation has finished
			if (solveAnimationTime <= 0)
			{
				solveAnimation = false;
			}
		}
	}

	/// <summary>
	/// Updates the animation and data of the cube turn
	/// </summary>
	private void UpdateCubeTurn()
	{

		// Update turn animation if not in solve animation
		if (isTurning && !solveAnimation)
		{

			// Percent progress through turn animation from 0 to 1
			float percent;

			// Update time progression
			turnTimer += Time.deltaTime;

			// Animation progress depends on whether the turn animation is
			// in progress or the simple color switch is in progress
			if (showTurn && currentTurnAxis != TurnAxis.None)
			{
				percent = turnTimer / turnTime;
			}
			else
			{
				percent = turnTimer / switchTime;
			}

			// If the animation is currently in progress
			if (percent <= 1f)
			{

				// If displaying turn animation update the turn rotation
				if (currentTurnAxis != TurnAxis.None && showTurn)
				{
					turnAxis[(int)currentTurnAxis].transform.localEulerAngles = new Vector3(0, currentTurnDegrees * percent);
				}

				// Highlight turn sticker color, if not showing colors make sure
				// the highlight color is grayed out
				if (showingColors)
				{
					cubiesMeshRenderers[currentTurnSticker - 1].material = colorsSelected[cubeColors[currentTurnSticker - 1]];
				}
				else
				{
					cubiesMeshRenderers[currentTurnSticker - 1].material = colorsSelected[6];
				}

				// Highlight stickers on face
				SetFaceHighlight(true);
			}

			// If the animation time has elapsed
			else
			{

				// Reset stickers rotation, position, and transform parents
				if (currentTurnAxis != TurnAxis.None)
				{
					turnAxis[(int)currentTurnAxis].transform.localEulerAngles = Vector3.zero;
					UpdateStickersParents(currentTurnSticker, turnAxis[(int)currentTurnAxis], false);
				}

				// Un-highlight turn sticker color, if not showing colors make sure
				// the highlight color is grayed out
				if (showingColors)
				{
					cubiesMeshRenderers[currentTurnSticker - 1].material = colors[cubeColors[currentTurnSticker - 1]];
				}
				else
				{
					cubiesMeshRenderers[currentTurnSticker - 1].material = colors[6];
				}

				// Un-highlight stickers on face
				SetFaceHighlight(false);

				// Update all sticker colors based on the sticker turn
				UpdateStickers(currentTurnSticker, currentTurnType);

				// Check if cube is solved
				if (IsSolved())
				{
					// Starts the solve animation
					timer.StopTimer();
					confetti.PartyTime();

					// Cube has been solved and is no longer scrambled
					cubeScrambled = false;

					// Show the solve and scramble moves
					scrambleText.ShowText();
					solveText.ShowMoves();

					// Cube stickers are set to show
					showColorsButton.SetButtonToggle(true);

					// Show sticker colors and activate solve animation
					solveAnimation = true;
					solveAnimationTime = 5.5f;
					if (!showingColors)
					{
						ToggleColorShow();
					}
				}

				// Cube is no longer turning
				isTurning = false;
			}
		}
	}

	/// <summary>
	/// Changes the position of the cube with given a perspective change
	/// </summary>
	/// <param name="perspective">Direction of perspective</param>
	public void ChangePerspective(Perspective perspective)
	{
		switch (perspective)
		{

			// Move cube down when looking at top perspective
			case Perspective.Top:
				transform.parent.localPosition =
					new Vector3(
						cubePosition.x,
						cubePosition.y - perspectiveOffset,
						cubePosition.z);
				break;

			// Center cube when looking at front perspective
			case Perspective.Normal:
				transform.parent.localPosition =
					new Vector3(
						cubePosition.x,
						cubePosition.y,
						cubePosition.z);
				break;

			// Move cube up when looking at bottom perspective
			case Perspective.Bottom:
				transform.parent.localPosition =
					new Vector3(
						cubePosition.x,
						cubePosition.y + perspectiveOffset,
						cubePosition.z);
				break;
		}
	}

	/// <summary>
	/// Checks whether the cube is solved
	/// </summary>
	/// <returns></returns>
	public bool IsSolved()
	{

		// If cube has not been scrambled the cube is not considered solved
		if (!cubeScrambled)
		{
			return false;
		}

		// If any sticker colors differ on the same face, it is not solved
		for (int i = 0; i < 6; i++)
		{
			int cubeColor = cubeColors[i * 9];
			for (int j = i * 9; j < (i + 1) * 9; j++)
			{
				if (cubeColors[j] != cubeColor)
				{
					return false;
				}
			}
		}

		// If all 6 faces have the same sticker colors it is solved
		return true;
	}

	/// <summary>
	/// Toggles whether to show the sticker colors or gray them out
	/// </summary>
	public void ToggleColorShow()
	{

		// Update show color variable
		showingColors = !showingColors;

		// Set each sticker material to show color or gray out
		for (int i = 0; i < 6; i++)
		{
			for (int j = 0; j < 9; j++)
			{
				if (showingColors)
				{
					cubiesMeshRenderers[9 * i + j].material = colors[cubeColors[9 * i + j]];
				}
				else
				{
					cubiesMeshRenderers[9 * i + j].material = colors[6];
				}
			}
		}
	}

	/// <summary>
	/// Toggles whether to show the turn animation and returns new value
	/// </summary>
	/// <returns></returns>
	public bool ToggleShowTurn()
	{
		showTurn = !showTurn;
		return showTurn;
	}

	/// <summary>
	/// Scrambles the cube and returns scramble moves
	/// Scramble moves example:
	/// "100 56 23 ... 178 67 "
	/// </summary>
	/// <returns>Space separated list of sticker moves</returns>
	public string Scramble()
	{

		// Starts scramble at solve state
		SetStartState();

		// Records each random sticker move
		string scrambleText = "";
		for (int i = 0; i < scrambleMoves; i++)
		{

			// Updates the scramble list and activates hypercube turn
			int randomNumber = UnityEngine.Random.Range(0, 6) * 9 + 5;
			scrambleText += randomNumber.ToString() + " ";
			UpdateStickers(randomNumber, TurnType.Clockwise);
		}

		// Cube has been scramblee and scrmable list is returned
		cubeScrambled = true;
		return scrambleText;
	}

	/// <summary>
	/// Sets the cube to the solved state
	/// </summary>
	public void SetStartState()
	{

		// Sets each sticker data to solve state and updates material to color
		// material or grayed out material
		for (int i = 0; i < 6; i++)
		{
			for (int j = 0; j < 9; j++)
			{
				if (showingColors)
				{
					cubiesMeshRenderers[9 * i + j].material = colors[i];
				}
				else
				{
					cubiesMeshRenderers[9 * i + j].material = colors[6];
				}
				cubeColors[9 * i + j] = i;
			}
		}

		// Cube is no longer scrambled
		cubeScrambled = false;
	}

	/// <summary>
	/// Activates turn of the cube
	/// Does not activate while in solve animation or already in turn animation
	/// </summary>
	/// <param name="stickerIndex">Sticker that has been selected</param>
	/// <param name="turnType">Type of turn applied to sticker</param>
	public void Turn(int stickerIndex, TurnType turnType)
	{

		// Does not activate while in turn animation
		if (!isTurning)
		{

			// Resets turn timer
			turnTimer = 0f;

			// Amount of degrees to rotate around
			float degrees = 0;

			// Gets the turn degrees based on type of turn
			switch (turnType)
			{
				case TurnType.Clockwise:
					degrees = 90;
					break;
				case TurnType.HalfTurn:
					degrees = 180;
					break;
				case TurnType.CounterClockwise:
					degrees = -90;
					break;
				case TurnType.FaceCentralizer:
					degrees = 0;
					break;
			}

			// Gets the axis to turn around
			TurnAxis stickerTurnAxis = GetAxisFromSticker(stickerIndex);

			// Reverses the direction of turn if opposite of positive y-axis
			// of the turn axis
			degrees *= ReverseTurnDirection(stickerIndex) ? -1 : 1;

			// If the sticker applies turn animation, then update stickers
			// parents that rotate around turn axis
			if (stickerTurnAxis != TurnAxis.None && showTurn)
			{
				UpdateStickersParents(stickerIndex, turnAxis[(int)stickerTurnAxis], true);
			}

			// Updates the data for the current turn axis, sticker, degrees,
			// turn type, and turn begins
			currentTurnAxis = stickerTurnAxis;
			currentTurnSticker = stickerIndex;
			currentTurnDegrees = degrees;
			currentTurnType = turnType;
			isTurning = true;

			// These record the turns to the solve moves list, the moves are
			// recorded 1, 2, or 3 times because turns indicate only clockwise
			// moves

			// In middle move repeat 1 for clockwise, 2 for half turn,
			// and 3 for counterclockwise turn
			if (turnType == TurnType.Clockwise)
			{
				solveText.AddMove(stickerIndex);
			}
			else if (turnType == TurnType.HalfTurn)
			{
				solveText.AddMove(stickerIndex);
				solveText.AddMove(stickerIndex);
			}
			else if (turnType == TurnType.CounterClockwise)
			{
				solveText.AddMove(stickerIndex);
				solveText.AddMove(stickerIndex);
				solveText.AddMove(stickerIndex);
			}
			else if (turnType == TurnType.FaceCentralizer)
			{

				// 100 multiple indicates face centralizer
				solveText.AddMove(stickerIndex * 100);
			}

		}
	}

	/// <summary>
	/// Initializes the structure of the cube faces
	/// </summary>
	private void SetupCubeStructure()
	{

		// Face game objects
		faces = new GameObject[6];

		// Main section parent created
		mainSection = new GameObject();
		mainSection.transform.parent = transform;
		mainSection.name = "MainSection";

		// Inside and outside hyperfaces created
		core = Instantiate(corePrefab);
		core.transform.parent = mainSection.transform;
		core.name = "Core";

		// Faces are created
		for (int i = 0; i < 6; i++)
		{
			faces[i] = Instantiate(facePrefab);
			faces[i].transform.parent = mainSection.transform;
			faces[i].name = sideNames[i] + "Face";
		}

		// Rotations are applied to faces
		for (int i = 0; i < 6; i++)
		{
			Quaternion quaternionRotation = new Quaternion();
			quaternionRotation.eulerAngles = cubesEulerAngles[i];
			faces[i].transform.localRotation = quaternionRotation;
			faces[i].transform.localPosition = facePositions[i];
		}

		// Scales and positions the entire hypercube
		transform.localScale = new Vector3(cubeScale, cubeScale, cubeScale);
		transform.parent.localPosition = cubePosition;
	}

	/// <summary>
	/// Assigns the stickers data and materials
	/// </summary>
	private void AssignCubies()
	{

		// Array of sticker game objects
		stickers = new GameObject[54];

		// Mesh renderers of the stickers
		cubiesMeshRenderers = new MeshRenderer[54];

		// Data for the sticker color
		cubeColors = new int[54];

		// Counter for the sticker index
		int indexCounter = 0;

		// Stickers/cubies and their parents for the pieces that are rotated in the
		// turn animations
		cubeTurnStickerParents = new Transform[81];
		cubeTurnStickerChildren = new Transform[81];

		// Iterates over each sticker and initializes its color and index
		// Iterates over each face, then column, and row
		for (int i = 0; i < 6; i++)
		{
			GameObject face = faces[i];
			for (int j = 1; j <= 3; j++)
			{
				GameObject row = face.transform.Find("Column" + j).gameObject;
				for (int k = 1; k <= 3; k++)
				{

					// Initializes its sticker data and name to its index
					stickers[cubiesMapping[indexCounter]] = row.transform.Find("Cube" + k).gameObject;
					stickers[cubiesMapping[indexCounter]].name = "Sticker" + (1 + cubiesMapping[indexCounter]);

					// Initialize the sticker transform and parent data
					cubeTurnStickerParents[cubiesMapping[indexCounter]] = row.transform;
					cubeTurnStickerChildren[cubiesMapping[indexCounter]] = stickers[cubiesMapping[indexCounter]].transform;
					indexCounter++;
				}

			}
		}

		// Iterates over each core cubie
		// Iterates over each layer, then row, and column
		coreCubies = new GameObject[27];
		for (int i = 1; i <= 3; i++)
		{
			GameObject row = core.transform.Find("Row" + i).gameObject;
			for (int j = 1; j <= 3; j++)
			{
				GameObject column = row.transform.Find("Column" + j).gameObject;
				for (int k = 1; k <= 3; k++)
				{
					// Initialize the sticker transform and parent data
					coreCubies[indexCounter - 54] = column.transform.Find("Cube" + k).gameObject;
					cubeTurnStickerParents[indexCounter] = column.transform;
					cubeTurnStickerChildren[indexCounter] = coreCubies[indexCounter - 54].transform;
					indexCounter++;
				}
			}
		}

		// Initializes the mesh renderers and color data of the stickers in index order
		for (int i = 0; i < 6; i++)
		{
			for (int j = 0; j < 9; j++)
			{
				cubiesMeshRenderers[9 * i + j] = stickers[9 * i + j].GetComponent<MeshRenderer>();
				cubiesMeshRenderers[9 * i + j].material = colors[i];
				cubeColors[9 * i + j] = i;
			}
		}
	}

	/// <summary>
	/// Gets the type of sticker by the index range (1 - 54)
	/// </summary>
	/// <param name="index">Index of the sticker</param>
	/// <returns>Type of sticker</returns>
	private StickerType GetStickerTypeFromIndex(int index)
	{

		// Center sticker index
		if (index % 9 == 5)
		{
			return StickerType.Center;
		}

		// Corner sticker indexes
		else if (index % 9 == 1 || index % 9 == 3 || index % 9 == 7 || index % 9 == 9)
		{
			return StickerType.Corner;
		}

		// Otherwise sticker index is edge
		return StickerType.Edge;
	}

	/// <summary>
	/// Updates the parents of the turn animation stickers
	/// </summary>
	/// <param name="axis">Game object of the turn axis</param>
	/// <param name="toAxis">
	/// Whether to apply sticker parent to axis or original parent
	/// </param>
	private void UpdateStickersParents(int stickerIndex, GameObject axis, bool toAxis)
	{

		// The index [0, 5] of the turn type: Front, back, top, bottom, right, left
		int turnIndex = (stickerIndex - 5) / 9;

		// Iterates over each sticker in list of turn animation stickers
		for (int i = 0; i < 54; i++)
		{

			// If the sticker index is on the turning section
			bool containsElement = false;
			for (int j = 0; j < turnStickers.GetLength(1); j++)
			{
				if (turnStickers[turnIndex, j] == (i + 1))
				{
					containsElement = true;
					break;
				}
			}

			// If sticker is on turning section and settings parent to turn axis
			if (containsElement && toAxis)
			{
				cubeTurnStickerChildren[i].parent = axis.transform;
			}

			// Sets parent to original parent
			if (!toAxis)
			{
				cubeTurnStickerChildren[i].parent = cubeTurnStickerParents[i];
			}

		}

		// Iterates over each core cubie in list of turn animation cubies
		for (int i = 0; i < 27; i++)
		{

			// If the cubie index is on the turning section
			bool containsElement = false;
			for (int j = 0; j < turnCubies.GetLength(1); j++)
			{
				if (turnCubies[turnIndex, j] == (i + 1))
				{
					containsElement = true;
					break;
				}
			}

			// If cubie is on turning section and settings to turn axis
			if (containsElement && toAxis)
			{
				cubeTurnStickerChildren[54 + i].parent = axis.transform;
			}

			// Sets parent to original parent
			if (!toAxis)
			{
				cubeTurnStickerChildren[54 + i].parent = cubeTurnStickerParents[54 + i];
			}
		}
	}

	/// <summary>
	/// Updates the sticker colors based on the sticker turn
	/// </summary>
	/// <param name="stickerIndex">Index of the sticker turn selected</param>
	/// <param name="turnType">Type of turn applied to the sticker</param>
	private void UpdateStickers(int stickerIndex, TurnType turnType)
	{

		// Gets the cycle notation based on the sticker turn data
		// Example: {{1, 2}, {3, 4, 5}} swaps stickers with index 1 and 2
		// and color on index 3 goes to index 4, color index 4 goes to 5, and
		// color on index 5 goes to index 3
		int[,] cycles = TurnCycles.GetCycles(stickerIndex, turnType);

		// Iterates over each of the cycles
		for (int i = 0; i < cycles.GetLength(0); i++)
		{

			// Identity does not rotate any stickers
			if (cycles.GetLength(1) == 0)
			{
				break;
			}

			// Value of the last index in the cycle
			int endIndex = cycles.GetLength(1) - 1;

			// Saves the color of the sticker on the end index
			int tempColor = cubeColors[cycles[i, endIndex] - 1];

			// Sets each sticker color to the color of the sticker at the index
			// of the cycle before it, starting at the end of the cycle
			for (int j = endIndex; j > 0; j--)
			{

				// Updates sticker color value
				cubeColors[cycles[i, j] - 1] = cubeColors[cycles[i, j - 1] - 1];

				// Updates sticker visual color if showing colors
				if (showingColors)
				{
					cubiesMeshRenderers[cycles[i, j] - 1].material = colors[cubeColors[cycles[i, j] - 1]];
				}
			}

			// Updates the color of the cycle start index to the saved end index color
			// Updates sticker color value
			cubeColors[cycles[i, 0] - 1] = tempColor;

			// Updates sticker visual color if showing colors
			if (showingColors)
			{
				cubiesMeshRenderers[cycles[i, 0] - 1].material = colors[cubeColors[cycles[i, 0] - 1]];
			}
		}
	}

	/// <summary>
	/// Checks if center sticker selected, which visually highlights whole face
	/// </summary>
	/// <param name="highlight">Whether to highlight or un-highlight face</param>
	private void SetFaceHighlight(bool highlight)
	{

		// Relative piece to inside stickers
		int relativePiece = currentTurnSticker % 9;

		// Index of the hyperface selected
		int cubeFace = (currentTurnSticker - 1) / 9;

		// If the center sticker has been selected
		if (relativePiece == 5)
		{

			// Iterate over each of the 9 stickers on the face
			for (int i = 0; i < 9; i++)
			{

				// Index of sticker on face
				int highlightSticker = 9 * cubeFace + i;

				// Update sticker highlight
				UpdateStickerHighlight(highlightSticker, highlight);
			}
		}
	}

	/// <summary>
	/// Updates the highlight of the given sticker adaptive to
	/// whether the sticker is grayed out
	/// </summary>
	/// <param name="stickerIndex">Index of the sticker</param>
	/// <param name="highlight">Whether to highlight the sticker</param>
	private void UpdateStickerHighlight(int stickerIndex, bool highlight)
	{

		// Highlight the sticker to color
		if (highlight && showingColors)
		{
			cubiesMeshRenderers[stickerIndex].material = colorsSelected[cubeColors[stickerIndex]];
		}

		// Highlight the sticker to grayed out highlight
		else if (highlight && !showingColors)
		{
			cubiesMeshRenderers[stickerIndex].material = colorsSelected[6];
		}

		// Un-highlight the sticker to color
		else if (!highlight && showingColors)
		{
			cubiesMeshRenderers[stickerIndex].material = colors[cubeColors[stickerIndex]];
		}

		// Un-highlight the sticker to grayed out highlight
		else if (!highlight && !showingColors)
		{
			cubiesMeshRenderers[stickerIndex].material = colors[6];
		}
	}

	/// <summary>
	/// Gets the axis of rotation based on the given sticker index
	/// Must be one of: 5, 14, 23, 41, 50
	/// </summary>
	/// <param name="stickerIndex">Sticker turn index</param>
	/// <returns></returns>
	private TurnAxis GetAxisFromSticker(int stickerIndex)
	{
		switch (stickerIndex)
		{
			case 5:
				return TurnAxis.FaceFront;
			case 14:
				return TurnAxis.FaceFront;
			case 23:
				return TurnAxis.FaceTop;
			case 32:
				return TurnAxis.FaceTop;
			case 41:
				return TurnAxis.FaceRight;
			case 50:
				return TurnAxis.FaceRight;
		}

		// Invalid sticker returns none
		return TurnAxis.None;
	}

	/// <summary>
	/// Returns whether the given sticker points in the negative direction of
	/// the turn axis
	/// See TurnAxis enum to see sticker pointing in positive direction
	/// </summary>
	/// <param name="stickerIndex">Index of the sticker</param>
	/// <returns>
	/// Whether the sticker points in the negative direction of the turn axis
	/// </returns>
	private bool ReverseTurnDirection(int stickerIndex)
	{
		switch (stickerIndex)
		{
			case 14:
				return true;
			case 32:
				return true;
			case 50:
				return true;
		}
		return false;
	}

	/// <summary>
	/// Initializes the structure and data of the turn axis
	/// </summary>
	private void SetupTurnAxis()
	{

		// Turn axis transforms
		Transform[] turns = new Transform[3];

		// Turn axis game objects initialized
		turnAxis = new GameObject[3];
		turnAxisPrefab = Instantiate(turnAxisPrefab);

		// Turn axis parent is under the main section
		turnAxisPrefab.transform.parent = transform.Find("MainSection");
		turnAxisPrefab.transform.localPosition = Vector3.zero;
		turnAxisPrefab.name = "TurnAxis";

		// Initialize the transform data of the turns
		turns[0] = turnAxisPrefab.transform.Find("FaceTop");
		turns[1] = turnAxisPrefab.transform.Find("FaceRight");
		turns[2] = turnAxisPrefab.transform.Find("FaceFront");

		// Initialize the transforms of the turn axis to the turns parents
		for (int i = 0; i < 3; i++)
		{
			turnAxis[i] = turns[i].Find("RotationParent").gameObject;
		}
	}
}
